# Руководство Google по оформлению кода на языке Java (Google Java Style Guide)

## 1. Введение 
Этот документ является **полным** определением стандартов Google относительно оформления исходного кода на языке программирования Java™. Исходный файл Java считается оформленным в соответствии с *Google Java Style* в том и только в том случае, если он соответствует приведённым здесь правилам.

Как и другие руководства по стилю программирования, эти правила охватывают не только эстетические вопросы форматирования, но и другие соглашения и стандарты кодирования. В этом документе основное внимание уделяется **строгим правилам**, которым мы следуем. Документ избегает давать *советы*, которые не могут быть чётко исполнены (неважно, человеком или инструментом).

Оригинал документа: [https://google.github.io/styleguide/javaguide.html](https://google.github.io/styleguide/javaguide.html)

### 1.1. Заметки по терминологии 
В этом документе, если не указано иное:

1. Термин *класс* используется для обозначения «обычного» класса, перечисляемого класса, интерфейса или типа аннотации (`@interface`).
2. Термин *член класса* используется для обозначения вложенного класса, поля, метода *или конструктора*, то есть, всего содержимого класса верхнего уровня, кроме инициализаторов и комментариев.
3. Термин *комментарий* всегда относится к комментариям *реализации*. Мы не используем фразу «комментарии для документации», вместо этого используем общий термин «Javadoc».

Другие примечания по терминологии будут время от времени появляться в продолжение всего документа.

### 1.2. Примеры кода 
Примеры кода в этом документе **не являются нормативными**. То есть, хотя примеры оформлены стиле Google Java Style, они могут иллюстрировать *лишь один* способ представления кода. Варианты форматирования, данные в примерах, не должны применяться в качестве правил.

## 2. Основные правила для файлов исходного кода 
### 2.1. Имя файла 
Имя файла исходного кода должно состоять из имени класса верхнего уровня, находящегося в этом файле, а также расширения `.java`. Файл должен содержать ровно один класс верхнего уровня (см. [п.3.4.1](#ровно-одно-объявление-класса-верхнего-уровня))

### 2.2. Кодировка файла 
Исходные файлы должны кодироваться в **UTF-8**.

### 2.3. Специальные символы 
#### 2.3.1. Пробельные символы 
В исходном файле в качестве пробельных символов допустимо использовать либо символ перевода строки, либо **горизонтальный пробел ASCII (0x20)**. Это подразумевает, что:
1. Все другие пробельные символы в строковых и символьных литералах экранируются.
2. Символы табуляции **не** используются для отступа.

#### 2.3.2. Специальные escape-последовательности 
Для любого символа, который имеет [специальную управляющую последовательность](http://docs.oracle.com/javase/tutorial/java/data/characters.html) (`\b`, `\t`, `\n`, `\f`, `\r`, `\"`, `\'` и `\\`), эта последовательность должна использоваться вместо соответствующей этому символу восьмеричной нотации (например, `\012`) или нотации Unicode (например, `\u000a`).

#### 2.3.3. Не-ASCII символы 
Для остальных не-ASCII символов должен использоваться либо фактический символ Unicode (например, `∞`), либо эквивалентный escape-код Unicode (например,  `\u221e`). Выбор зависит только от того, что делает код **более легким для чтения и понимания**. Применение escape-кодов Unicode вне строковых литералов и комментариев настоятельно не рекомендуется.
> Совет: В случае использования escape-кодов Unicode, а иногда и при использовании реальных символов Unicode, очень полезен пояснительный комментарий.

Примеры:

<table>
    <tr>
        <td>Пример</td>
        <td>Примечание</td>
    </tr>
    <tr>
        <td>String unitAbbrev = "μs";</td>
        <td>Лучше всего: совершенно ясно, даже без комментариев</td>
    </tr>
    <tr>
        <td>String unitAbbrev = "\u03bcs"; // "μs"</td>
        <td>Разрешено, но нет причин так делать</td>
    </tr>
    <tr>
        <td>String unitAbbrev = "\u03bcs"; // Greek letter mu, "s"</td>
        <td>Разрешено, но некрасиво и может привести к ошибкам</td>
    </tr>
    <tr>
        <td>String unitAbbrev = "\u03bcs";</td>
        <td>Плохо: читатель понятия не имеет, что это такое</td>
    </tr>
    <tr>
        <td>return '\ufeff' + content; // byte order mark</td>
        <td>Хорошо: используй экранирование для непечатаемых символов и комментируй при необходимости</td>
    </tr>
</table>

> **Совет**: Никогда не делай свой код менее читабельным из-за опасения, что некоторые программы могут некорректно обрабатывать не-ASCII символы. Такие программы объективно сломаны, они должны быть пофикшены (или заменены).

## 3. Структура исходного файла 
Исходный файл должен состоять из следующих разделов, **в указанном порядке**:

1. Лицензия или информация об авторских правах, если таковые имеются
2. Инструкция package
3. Инструкции import
4. Ровно один класс высшего уровня

**Ровно одна пустая строка** должна отделять разделы друг от друга.

### 3.1. Лицензия или информация об авторских правах, если таковые имеются 
Если информация о лицензии или авторских правах уже есть в файле, она должна в нем остаться.

### 3.2. Инструкция package
Инструкция package **не должна содержать переносов строки**. Ограничение длины строки (см. [п.4.4](#ограничение-длины-строки)) не должно применяться к инструкции package.

### 3.3. Инструкции import
#### 3.3.1. Не импортировать по шаблону 
**Импорт по шаблону**, в том числе статический, **не должен использоваться**.

#### 3.3.2. Не переносить строки 
Инструкция import **не должна содержать переносов строки**. Ограничение длины строки (см. [п.4.4](#ограничение-длины-строки)) не должно применяться к инструкциям import.

#### 3.3.3. Порядок и интервалы 
Импорты должны быть упорядочены следующим образом:

1. Все статические импорты одним блоком.
2. Все нестатические импорты одним блоком.

Если есть как статический, так и нестатический импорт, блоки должны отделяться одной пустой строкой.

В каждом блоке имена импортированных сущностей должны отображаться в порядке сортировки ASCII. (**Примечание**: это не то же самое, что операторы импорта в порядке сортировки ASCII, т.к. в этом случае '.' оказывается перед ';')

#### 3.3.4. Не импортировать классы статически  
Статический импорт не должен использоваться для статических вложенных классов. Они должны импортироваться обычным импортом.

### 3.4. Объявление класса
#### 3.4.1. Ровно одно объявление класса верхнего уровня
Каждый класс верхнего уровня должен находиться в отдельном исходном файле.

#### 3.4.2. Порядок следования содержимого классов
Порядок, который ты выберешь для членов и инициализаторов класса, может оказать большое влияние на читаемость. Как бы то ни было, не существует единственно правильного рецепта, как это сделать. Разные классы могут иметь разный порядок содержимого.

Важно то, что каждый класс должен иметь ***некоторый*** **логический порядок**, который может быть объяснён его создателем. Например, новые методы не нужно просто добавлять в конец класса, так как это приведет к их упорядочиванию в хронологическом порядке, а это не является логическим упорядочением.

#### 3.4.2.1. Перегруженные методы: никогда не разделяются другим кодом
Если в классе есть несколько конструкторов или несколько методов с одним и тем же именем, они должны быть помещены рядом, без иного кода между ними.

## 4. Форматирование
**Замечание по терминологии**: Термин *блочная конструкция* обозначает тело класса, метода или конструктора. Обрати внимание, что согласно [п.4.8.3.1](#инициализаторы-массивов-могут-быть-оформлены-как-блок) об инициализаторах массива любой инициализатор массива *может* опционально рассматриваться как блочная конструкция.

### 4.1. Фигурные скобки 
#### 4.1.1. Фигурные скобки даже там, где это необязательно 
Фигурные скобки должны использоваться с инструкциями `if`, `else`, `for`, `do` и `while` даже тогда, когда тело пустое или содержит только один оператор.

#### 4.1.2. Непустые блоки в стиле K&R
Использование фигурных скобок должно соответствовать стилю K&R (Керниган и Ритчи - «[египетские скобки](http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html)») для *непустых* блоков и блочных конструкций:

 - Без разрыва строки перед открывающей скобкой.
 - Разрыв строки после открывающей скобки.
 - Разрыв строки перед закрывающей скобкой.
 - Разрыв строки после закрывающей скобки, *только если* эта скобка завершает оператор или завершает тело метода, конструктора или *именованного* класса. Например, после фигурной скобки *не должно быть* разрыва строки, если за ней следует `else` или запятая.

Примеры:
```java
return () -> {
  while (condition()) {
    method();
  }
};

return new MyClass() {
  @Override public void method() {
    if (condition()) {
      try {
        something();
      } catch (ProblemException e) {
        recover();
      }
    } else if (otherCondition()) {
      somethingElse();
    } else {
      lastThing();
    }
  }
};
```

Несколько исключений для классов enum приведены в [п.4.8.1](#перечисления).

#### 4.1.3. Пустые блоки могут быть сокращены 
Пустой блок или блочная конструкция могут быть оформлены в стиле K & R (как описано в [п.4.1.2](#непустые-блоки-в-стиле-kr)). 
Альтернативно блок может быть закрыт сразу после открытия, без символов или разрыва строки между фигурными скобками (`{}`), если только он не является частью *многоблочного оператора* (оператор, непосредственно включающий в себя несколько блоков: `if/else` или `try/catch/finally`).

Примеры:
```java
// Допустимо
void doNothing () {}
   
// Допустимо
void doNothingElse () {
}
  
// Недопустимо: в многоблочной инструкции не должно быть сокращнных пустых блоков
try { 
    doSomething (); 
} catch ( Exception e ) {}
```

### 4.2. Отступ блока: +2 пробела 
Каждый раз, когда открывается новый блок или блочная конструкция, отступ должен быть увеличен на два пробела. Когда блок заканчивается, отступ возвращается к предыдущему уровню отступа. Уровень отступа применяется как к коду, так и к комментариям по всему блоку (см. пример в [п.4.1.2](#непустые-блоки-в-стиле-kr)).

### 4.3. Одно выражение на строку 
Каждое выражение должно заканчиваться переводом строки.

### 4.4. Ограничение длины строки
Java-код должен иметь ограничение по длине строки в 100 символов. «Символ» означает любую кодовую точку Unicode. За исключением отмеченного ниже, любая строка, которая превышает этот предел, должна быть перенесена, как описано в [п.4.5](#переносы-строк).

> Каждая кодовая точка Unicode считается одним символом, даже если ширина её отображения больше или меньше. Например, при использовании [полноширинных символов](https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms) (некоторый набор символов вдвое шире обычных) можно сделать перенос строки раньше, чем это требуется согласно этому правилу.

**Исключения**:

1. Строки, в которых невозможно расставить переносы (например, длинный URL-адрес в Javadoc или длинная ссылка на метод JSNI).
2. Операторы `package` и `import` (см. [п.3.2](#инструкция-package) и [п.3.3](#инструкции-import)).
3. Командные строки в комментариях. Они должны остаться таком виде, чтобы их можно было скопировать и вставить в shell.

### 4.5. Переносы строк 
**Примечание по терминологии**: Когда код, который может законно занимать одну строку, разбивается на несколько строк, это действие называется *переносом строк*.

Не существует всеобъемлющей, детерминированной формулы, объясняющей, как *именно* переносить строки в каждой ситуации. Очень часто существует несколько допустимых способов переноса строк в одном и том же фрагменте кода.

> **Примечание**: Основная причина переноса строк – ограничение по длине строки, но даже код, который на самом деле помещается в пределах столбца, *может* быть перенесён по усмотрению автора.

> **Совет**: Выделение метода или локальной переменной может решить проблему без необходимости переноса строки.

#### 4.5.1. Где ставить разрыв  
Основная директива переноса строк такова: нужно делать разрыв строки на **как можно более высоком синтаксическом уровне**. К тому же:

1. Если строка разрывается *не в операторе присваивания*, перенос необходимо сделать *до* символа оператора.
   - Это правило также применяется к следующим похожим на операторы символам:
     1. точка-разделитель (`.`)
     2. двойное двоеточие ссылки на метод (`::`)
     3. амперсанд в ограничении типа (`<T extends Foo & Bar>`)
     4. вертикальная черта в блоке `catch (FooException | BarException e)`
2. Если строка разрывается в операторе *присваивания*, перенос лучше сделать *после* символа присваивания, но допустимо сделать и до.
   - Это правило применяется и к двоеточию в операторе `foreach`.
3. Имя метода или конструктора необходимо оставить на строке вместе с открывающей круглой скобке (`(`), следующей за ним.
4. Запятую (`,`) необходимо оставить на одной строке с к предшествующей ей лексемой.
5. Строку недопустимо разрывать с любой стороны от стрелки в лямбде, за исключением случаев, когда тело лямбды состоит из одного не заключённого в скобки выражения. Тогда допустимо поставить разрыв сразу после стрелки. Примеры:

```java
MyLambda<String, Long, Object> lambda =
  (String label, Long value, Object obj) -> {
     ...
  };

Predicate<String> predicate = str ->
  longExpressionInvolving (str);
```

> **Примечание**: Основная цель переноса строк - улучшение чистоты кода, а *не* получение кода, который помещается в наименьшее количество строк.

#### 4.5.2. Продолжение переноса строки: +4 пробела
При переносе строк каждая строка после первой (каждая *строка продолжения*) должна иметь отступ не менее +4 от исходной строки.

По желанию при таком переносе можно отступать больше чем на +4 пробела. Как правило, две строки продолжения располагают на одном уровне отступа тогда и только тогда, когда они начинаются с синтаксически эквивалентных элементов.

В [п.4.6.3](#горизонтальное-выравнивание-не-требуется) освещается нежелательная практика использования переменного количества пробелов для выравнивания определенных лексем с предыдущими строками.

### 4.6. Пробелы
#### 4.6.1. Вертикальные пробелы 
Одна пустая строка должна всегда добавляться:

1. *Между* следующими друг за другом членами или инициализаторами класса: полями, конструкторами, методами, вложенными классами, статическими инициализаторами и инициализаторами экземпляров.
   - **Исключение**: пустая строка между двумя следующими друг за другом полями (без другого кода между ними) не обязательна. Такие пустые строки используются по мере необходимости для создания *логических группировок* полей.

   - **Исключение**: расстановка пустых строк между константами перечисления (enum) рассматриваются в [п.4.8.1](#перечисления).

2. В соответствии с требованиями других разделов этого документа (таких как [п.3](#структура-исходного-файла) и [п.3.3](#инструкции-import)).

Одна пустая строка может также использоваться везде, где это улучшает читабельность, например, между операторами, чтобы организовать код в логические подразделы. Пустая строка перед первым членом или инициализатором или после последнего члена или инициализатора класса ни поощряется, ни осуждается.

Допускается ставить *несколько* последовательных пустых строк, но это не требуются ни в каких случаях (а также не поощряется).

#### 4.6.2. Горизонтальные пробелы
Кроме тех случаев, где использование пробелов диктуется требованиями языка или другими правилами Google Java Style, а также кроме литералов, комментариев и Javadoc, один пробел ASCII должен использоваться **только** в следующих местах:

1. Отделение любого зарезервированного слова, например `if`, `for` или `catch` от следующей за ним на той же строке открывающей скобки (`(`)
2. Отделение любого зарезервированного слова, такого как `else` или `catch`, от предшествующей ему на той же строке закрывающей фигурной скобки (`}`)
3. Перед любой открывающей фигурной скобкой (`{`), с двумя исключениями:
   - `@SomeAnnotation({a, b})` (пробел не используется)
   - `String[][] x = {{"foo"}};` (пробел, описанный в пп. 8, не требуется между `{{`)
4. С обеих сторон любого бинарного или тернарного оператора. Правило также применяется к следующим похожим на операторы символам:
   - амперсанд в ограничении типа: `<T extends Foo & Bar>`
   - вертикальная черта в блоке catch, обрабатывающем несколько исключений: `catch (FooException | BarException e)`
   - двоеточие (`:`) в расширенном операторе `for` (`foreach`)
   - стрелка в лямбда-выражении: `(String str) -> str.length()`
   
   Правило не применяется в следующих случаях:
   - два двоеточия (`::`) ссылки на метод, записывающейся как `Object::toString`
   - точка-разделитель (`.`), например, `object.toString()`
5. После `,:;` или закрывающей скобки (`)`) приведения типа
6. По обе стороны от двойной косой черты (`//`), начинающей комментарий. Здесь разрешено использовать нескольких пробелов, но это не обязательно.
7. Между типом и переменной объявления: `List<String> list`
8. *Необязательно* внутри обеих фигурных скобок инициализатора массива
   - `new int[] {5, 6}` и `new int[] { 5, 6 }` равнозначно корректны
9. Между аннотацией типа и `[]` или `...` .

Это правило никогда не требует добавлять пробел в начало или конец строки; правило работает только для *внутреннего* наполнения строк.

#### 4.6.3. Горизонтальное выравнивание не требуется
**Примечание по терминологии**: *Горизонтальное выравнивание* - это практика добавления в код переменного числа дополнительных пробелов с целью отображения определенных лексем непосредственно под некоторыми другими лексемами в предыдущих строках.

Эта практика разрешена, но **никогда не требуется** в Google Java Style. Также не требуется *поддерживать* горизонтальное выравнивание в тех местах, где оно уже используется.

Вот пример без выравнивания, а затем с использованием выравнивания:
```java
private int x; // ok
private Color color; // тоже ok

private int       x;        // разрешено, но при будущем редактировании
private Color color; // выравнивание может не сохраниться
```

> **Совет**: Выравнивание может улучшать читаемость, но создает проблемы для дальнейшей поддержки кода. Рассмотрим будущее изменение, которое коснётся только одной строки. Это изменение может исказить ранее выполненное выравнивание, и это **разрешено**. Часто это провоцирует кодировщика (возможно, вас) подгонять пробелы на соседних строках, вызывая цепочку переформатирований. Таким образом, изменение одной строки будет иметь некоторый «радиус взрыва». В худшем случае это может привести к бессмысленной работе, но и в лучшем случае это искажает информацию об истории версий, замедляет ревью и усугубляет конфликты слияний.

### 4.7. Скобки для группировки рекомендуются 
Необязательные скобки для группировки опускаются только если и автор, и ревьювер согласны с тем, что без них код не может быть неверно интерпретирован, и что их наличие не улучшает читаемость кода. *Неправильно* считать, что каждый читатель помнит наизусть таблицу приоритета операторов.

### 4.8. Уточнения для некоторых конструкций 
#### 4.8.1. Перечисления 
После запятой, которая следует за константой перечисления, может ставиться разрыв строки. Дополнительные пустые строки (обычно только одна) также допускаются. Допустимый вариант:
```java
private enum Answer {
  YES {
    @Override public String toString() {
      return "yes";
    }
  },

  NO,
  MAYBE
}
```

Enum без методов и документации по его константам может быть отформатирован так, как если бы он был инициализатором массива (см. [п.4.8.3.1](#инициализаторы-массивов-могут-быть-оформлены-как-блок)).
```java
private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }
```

Поскольку перечисления *являются классами*, к ним применяются все остальные правила для форматирования классов.

#### 4.8.2. Объявление переменных 
##### 4.8.2.1. Одна переменная на объявление
Каждая переменная (как поле, так и локальная) должна быть объявлена отдельно. Объявления, такие как `int a, b;`, использоваться не должны.

**Исключение**: В заголовке цикла `for` допустимы множественные объявления переменных.

##### 4.8.2.2. Переменные объявляются по мере необходимости
Локальные переменные в общем случае **не** должны объявляться в начале блока или блочной конструкции. Вместо этого они должны объявляться незадолго (в пределах разумного) до первого использования, чтобы минимизировать их область видимости. Объявления локальных переменных обычно должны иметь инициализаторы, либо переменные должны инициализироваться сразу после объявления.

##### 4.8.3. Массивы 
##### 4.8.3.1. Инициализаторы массивов могут быть оформлены как блок
*Опционально* инициализатор массива может быть отформатирован, как если бы он был блочной конструкцией. Например, следующие примеры допустимы (список **не** исчерпывающий):
```java
new int[] {
  0, 1, 2, 3
}

new int[] {
  0, 1,
  2, 3
}

new int[] {
  0,
  1,
  2,
  3,
}

new int[]
    {0, 1, 2, 3}
```

##### 4.8.3.2. Недопустимо объявление массива в стиле C
Квадратные скобки являются частью *типа*, а не переменной: `String[] args`, а не `String args[]`.

#### 4.8.4. Операторы switch 
**Примечание по терминологии**: Внутри фигурных скобок *блока switch* находится одна или несколько *групп операторов*. Каждая группа операторов состоит из одной или нескольких *меток* (либо `case FOO:`, либо `default:`), за которой следует один или несколько операторов (или, для *последней* группы операторов, *ноль* или более операторов).

##### 4.8.4.1. Отступы
Как и в любом другом блоке, содержимое блока switch должно иметь отступ +2.

После метки должен присутствовать разрыв строки, и уровень отступа должен увеличиваться на +2, точно так же, как если бы начинался следующий блок. Следующая метка должна возвращать отступ к предыдущему уровню, как если бы блок закончился.

##### 4.8.4.2. Fall-through: необходим комментарий
В блоке switch каждая группа операторов должен либо завершаться явно (оператором `break`, `continue`, `return` или выбросом исключения), либо должен снабжаться комментарием, объясняющим, что исполнение будет или *может быть* продолжено в следующей группе операторов. Допустим любой комментарий, передающий саму идею продолжения выполнения в следующем блоке (как правило, `// fall through`). Такой комментарий не требуется в последней группе операторов блока переключателей. Пример:
```java
switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
    // fall through
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
}
```

Обрати внимание, что комментарий не требуется после `case 1:` и ставится только в конце группы операторов.

##### 4.8.4.3. Необходимо использовать метку default
Каждый оператор switch должен включать группу операторов `default`, даже если она не содержит кода.

**Исключение**: В операторе switch для типа `enum` группа `default` *может* отсутствовать, *если* switch включает *все* возможные значения этого типа. Это позволяет IDE и другим инструментам статического анализа кода выдавать предупреждение, если какие-то значения перечисления были пропущены.

#### 4.8.5. Аннотации
Аннотации, применяемые к классу, методу или конструктору, должны ставиться сразу после блока документации, и каждая аннотация должна указываться в отдельной строке (то есть, по одной аннотации на строку). Эти разрывы строк не являются переносом строк ([п.4.5](#переносы-строк)), поэтому уровень отступа не должен увеличиваться. Пример:
```java
@Override
@Nullable
public String getNameIfPresent() { ... }
```

**Исключение**: *Одна* аннотация без параметров *может* записываться в одну строку с сигнатурой, например:
```java
@Override public int hashCode() { ... }
```

Аннотации, применяемые к полю, также должны ставиться сразу после блока документации, но в этом случае *несколько* аннотаций (в том числе параметризованных) могут быть перечислены в одной строке, например:
```java
@Partial @Mock DataLoader loader;
```

Правила форматирования аннотаций к параметрам, локальным переменным и типам не определяются в Google Java Style.

#### 4.8.6. Комментарии
В этом разделе рассматриваются *комментарии реализации*. Javadoc рассматривается отдельно в [п.7](#javadoc).

Каждому разрыву строки может предшествовать необязательный пробел, за которым следует комментарий реализации. Такой комментарий делает строку непустой (?).

##### 4.8.6.1. Стиль блочного комментария
Блочные комментарии должны иметь тот же уровень отступов, что и окружающий их код. Они могут быть в стиле `/* ... */` или `// ...`. Для многострочных комментариев, оформленных в `/* ... */`, строки, начиная со второй, должны начинаться со `*`, выровненной со `*` на предыдущей строке.
```java
/*
 * Так
 * окей.
 */
 
// И так
// окей.
 
/* Можно сделать
 * даже так. */
```
 
Комментарии не должны оформляться в прямоугольники, образованные звездочками или другими символами.

> Совет: при написании многострочных комментариев используй стиль `/* ... */`, если хочешь, чтобы автоматические средства форматирования кода выполняли автоперенос строк комментариев при необходимости (согласно стилю абзаца). Большинство средств форматирования не переносят строки в однострочных комментариях типа `// ...`.

#### 4.8.7. Модификаторы
Модификаторы класса и членов класса, если они присутствуют, должны применяться в порядке, рекомендованном спецификацией языка Java:

`public protected private abstract default static final transient volatile synchronized native strictfp`

#### 4.8.8. Числовые литералы
Целочисленные литералы типа `long` должны содержать суффикс `L` в верхнем регистре, чтобы избежать путаницы с цифрой `1`. Например, `3000000000L`, а не `3000000000l`.

## 5. Имена идентификаторов 
### 5.1. Правила, общие для всех идентификаторов
В именах идентификаторов должны использоваться только буквы и цифры ASCII и в небольшом числе случаев, отмеченных ниже, подчёркивания. Таким образом, каждое допустимое имя идентификатора будет соответствовать регулярному выражению `\w+`.

В Google Java Style специальные префиксы или суффиксы **не разрешены**. Например, такие имена являются недопустимыми по Google Java Style: `name_`, `mName`, `s_name` и `kName`.

### 5.2. Правила по типам идентификаторов
#### 5.2.1. Имена пакетов
Все имена пакетов должны быть в нижнем регистре и содержать слова, просто соединенные вместе (без подчеркивания). Например `com.example.deepspace`, не `com.example.deepSpace` или `com.example.deep_space`.

#### 5.2.2. Имена классов
Имена классов должны быть в UpperCamelCase (см. [п.5.3](#алгоритм-преобразования-в-camel-case)).

Имена классов, как правило, должны быть существительными или именными фразами. Например, `Character` или `ImmutableList`. Имена интерфейсов также могут быть существительными или именными фразами (например, `List`), но иногда могут быть прилагательными или прилагательными фразами (например, `Readable`).

Не существует конкретных правил или даже устоявшихся соглашений для именования типов аннотаций.

*Тестовые* классы должны именоваться, начиная с имени класса, который они тестируют, и заканчивая `Test`. Например, `HashTest` или `HashIntegrationTest`.

#### 5.2.3. Имена методов
Имена методов должны быть в lowerCamelCase (см. [п.5.3](#алгоритм-преобразования-в-camel-case)).

Имена методов обычно должны быть глаголами или глагольными фразами. Например, `sendMessage` или `stop`.

Символы подчеркивания могут использоваться в именах методов *тестовых* классов JUnit для разделения логических частей имени, при этом *каждая* часть должна записываться в lowerCamelCase. Типичный шаблон: `<methodUnderTest>_<state>`, например, `pop_emptyStack`. Единого правильного способа называть методы тестовых классов не существует.

#### 5.2.4. Имена констант
Имена констант должны записываться в виде `CONSTANT_CASE`: все заглавные буквы, все слова разделены одним подчеркиванием. Но *что* такое константа?

Константы — это поля с модификаторами `static final`, содержимое которых является неизменным, а методы не имеют явных побочных эффектов. Это включает в себя примитивы, строки, неизменяемые (immutable) типы и неизменяемые коллекции неизменяемых типов. Если какое-либо наблюдаемое состояние экземпляра может измениться, он не является константой. Одного лишь `намерения` никогда не мутировать объект недостаточно. Примеры:
```java
// Constants
static final int NUMBER = 5;
static final ImmutableList<String> NAMES = ImmutableList.of("Ed", "Ann");
static final ImmutableMap<String, Integer> AGES = ImmutableMap.of("Ed", 35, "Ann", 32);
static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutable
static final SomeMutableType[] EMPTY_ARRAY = {};
enum SomeEnum { ENUM_CONSTANT }

// Not constants
static String nonFinal = "non-final";
final String nonStatic = "non-static";
static final Set<String> mutableCollection = new HashSet<String>();
static final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable);
static final ImmutableMap<String, SomeMutableType> mutableValues =
    ImmutableMap.of("Ed", mutableInstance, "Ann", mutableInstance2);
static final Logger logger = Logger.getLogger(MyClass.getName());
static final String[] nonEmptyArray = {"these", "can", "change"};
Для именования констант обычно используются существительные или именные фразы.
```

#### 5.2.5. Имена изменяемых полей
Имена изменяемые полей (в т.ч. статических) должны записываться в lowerCamelCase.

Для именования таких полей обычно используются существительные или именные фразы. Например, `computedValues` или `index`.

#### 5.2.6. Имена параметров
Имена параметров должны записываться в lowerCamelCase.

Следует избегать использования односимвольных имен параметров в публичных методах.

#### 5.2.7. Имена локальных переменных
Имена локальных переменных должны записываться в lowerCamelCase.

Неизменяемые локальные переменные с модификатором final не считаются константами, и их не следует оформлять как константы.

#### 5.2.8. Имена переменных типа 
Переменные типа должны именоваться в одном из двух стилей:

 - Одна заглавная буква, возможно с последующей одной цифрой (например `E`, `T`, `X`, `T2`)
 - Имя в форме имени класса (см. [п.5.2.2](#имена-классов)) с последующей заглавной буквой `T` Примеры: `RequestT`, `FooBarT`.

### 5.3. Алгоритм преобразования в camel case
Иногда существует несколько вариантов преобразования английской фразы в camel case, например, когда в имени присутствуют аббревиатуры или необычные конструкции, такие как «IPv6» или «iOS». Чтобы улучшить предсказуемость, Google Java Style определяет следующую (почти) детерминированную схему.
Начиная с обычной письменной формы имени:

1. Преобразуй фразу в обычный ASCII и удали все апострофы. Например, «Müller's algorithm» станет «Muellers algorithm».
2. Раздели результат на слова. Знаками разделения слов будут служить пробелы и оставшиеся знаки препинания (обычно дефисы).
   - *Рекомендуется*: если какое-то слово уже имеет общепринятую форму в camel case, раздели его на составные части (например, «AdWords» станет «ad words»). Следует отметить, что слова, подобные «iOS», не в camel case *сами по себе*, стиль их оформления вне *всех* соглашений, поэтому этот пункт к ним не применяется.
3. Преобразуй в строчные буквы *всё* (включая аббревиатуры), затем сделай прописными только первые символы:
   - ... каждого слова, чтобы получить *upper camel case*, или
   - ... каждого слова, кроме первого, чтобы получить *lower camel case*
4. Наконец, объедини все слова в один идентификатор.

Обрати внимание, что регистр исходных слов в полученном имени может почти полностью игнорироваться. Примеры:

<table>
    <tr>
        <td>Обычная письменная форма</td>
        <td>Правильно</td>
        <td>Неправильно</td>
    </tr>
    <tr>
        <td>"XML HTTP request"</td>
        <td>XmlHttpRequest</td>
        <td>XMLHTTPRequest</td>
    </tr>
    <tr>
        <td>"new customer ID"</td>
        <td>newCustomerId</td>
        <td>newCustomerID</td>
    </tr>
    <tr>
        <td>"inner stopwatch"</td>
        <td>innerStopwatch</td>
        <td>innerStopWatch</td>
    </tr>
    <tr>
        <td>"supports IPv6 on iOS?"</td>
        <td>supportsIpv6OnIos</td>
        <td>supportsIPv6OnIOS</td>
    </tr>
    <tr>
        <td>"YouTube importer"</td>
        <td>YouTubeImporter / YoutubeImporter*</td>
        <td></td>
    </tr>
</table>

\* Приемлемо, но не рекомендуется.

> **Примечание**: Некоторые слова английского языка могут иметь две формы написания, в одной из которых слово разделено дефисом. Например, формы "nonempty" и "non-empty" обе корректны, поэтому имена методов `checkNonempty` и `checkNonEmpty` также корректны.

## 6. Приёмы программирования 
### 6.1. @Override: используется всегда 
Метод должен помечаться аннотацией `@Override` всегда, когда это разрешено правилами языка: когда метод класса переопределяет метод суперкласса, метод класса реализует метод интерфейса и метод интерфейса повторно определяет метод родительского интерфейса.

**Исключение**: Аннотация `@Override` может быть опущена, если родительский метод `@Deprecated`.

### 6.2. Пойманные исключения не игнорируются
За исключением случаев, указанных ниже, очень редко бывает так, что ничего не нужно делать в ответ на пойманное исключение. Типичная реакция – залогировать это исключение, или, если даже это считается «невозможным», пробросить его как `AssertionError`.

В тех случаях, когда действительно уместно не предпринимать никаких действий в блоке catch, причина, по которой это сделано, должна объясняться в комментарии.
```java
try {
  int i = Integer.parseInt(response);
  return handleNumericResponse(i);
} catch (NumberFormatException ok) {
  // it's not numeric; that's fine, just continue
}
return handleTextResponse(response);
```

**Исключение**: В тестах пойманное исключение можно игнорировать без комментария, *если* его имя равно или начинается с `expected`. Ниже приведена очень распространенная идиома для проверки того, что испытываемый код `действительно` выбросит исключение ожидаемого типа, поэтому комментарий здесь не нужен.
```java
try {
  emptyStack.pop();
  fail();
} catch (NoSuchElementException expected) {
}
```

### 6.3. Статические члены: вызов через имя класса
В случаях, когда требуется ссылка на член статического класса, она должна уточняться через имя этого класса, а не через ссылку или выражение, имеющее тип этого класса.
```java
Foo aFoo = ...;
Foo.aStaticMethod(); // хорошо
aFoo.aStaticMethod(); // плохо
somethingThatYieldsAFoo().aStaticMethod(); // очень плохо
```

### 6.4. Финализаторы не используются 
Переопределять `Object.finalize` требуется **крайне редко**.

> **Совет**: Не делай этого. Если это просто необходимо, сначала внимательно прочитай и пойми главу «Остерегайтесь методов finalize» книги [«Java. Эффективное программирование»](https://www.ozon.ru/context/detail/id/148627191/) Джошуа Блоха, и уже тогда не делай этого.

## 7. Javadoc
### 7.1. Форматирование 
#### 7.1.1. Общий формат
*Базовое* форматирование блоков Javadoc показано в следующем примере:
```java
/**
 * Здесь присутствуют несколько строк Javadoc,
 * с обычными переносами...
 */
public int method(String p1) { ... }    
 ```

... и в этом однострочном примере:
```java
/ ** Очень короткий кусочек Javadoc. * /
```

Базовая форма приемлема всегда. Однострочная форма может применяться, когда весь блок Javadoc (включая маркеры комментариев) помещается на одной строке. Обрати внимание, что это применимо только тогда, когда нет таких блочных тегов, как `@return.`

#### 7.1.2. Параграфы
Одна пустая строка, то есть строка, содержащая только выровненную ведущую звездочку (`*`), должна разделять абзацы и группы тегов блока, если таковые имеются. Каждый абзац, кроме первого, должен содержать `<p>` непосредственно перед первым словом, без пробела после.

#### 7.1.3. Теги блоков
Стандартные «теги блоков» должны указываться в порядке `@param`, `@return`, `@throws`, `@deprecated`. Теги не могут использоваться с пустым описанием. Если тег не помещается на одной строке, строки продолжения должны иметь отступ в четыре (или более) пробела от позиции символа `@`.

### 7.2. Фрагмент краткой информации
Каждый блок Javadoc должен начинаться с **фрагмента краткой информации**. Этот фрагмент очень важен: это единственная часть текста, которая появляется в таких контекстах, как индексы классов и методов.

Этот фрагмент должен представлять собой именную или глагольную фразу, а не полное предложение. Он **не** должен начинаться с `Класс {@code Foo} - это...` или `Этот метод возвращает ...`, не должен представлять собой полное повелительное предложение вроде `Сохранить запись...`. Однако, фрагмент должен начинаться с заглавной буквы и иметь пунктуацию, как если бы это было полное предложение.

> **Совет**: Распространенной ошибкой является написание однострочного Javadoc в форме 
`/** @return ID клиента */`. Это неверно, такую строку требуется исправить на `/** Возвращает ID клиента. */`.

### 7.3. Где используется Javadoc
*Как минимум*, Javadoc необходимо добавлять для каждого `public` класса и каждого `public` или `protected` члена такого класса, за некоторыми исключениями, указанными ниже.

Дополнительный контент Javadoc также может присутствовать, как это объясняется в [п.7.3.4](#необязательный-javadoc).

#### 7.3.1. Самодокументируемые методы
Javadoc не обязателен для «простых, очевидных» методов, таких как `getFoo`, в тех случаях, когда о методе *действительно* нечего больше сказать, кроме как «Возвращает foo».

> **Важно**: неуместно ссылаться на это исключение, чтобы оправдать отсутствие релевантной информации, которая может потребоваться обычному читателю. Например, для метода, названного `getCanonicalName`, не игнорируй его документацию (с обоснованием, что вся документация уместится в строку `/** Возвращает каноническое имя. */`), если обычный читатель может не иметь представления о том, что означает термин «каноническое имя»!

#### 7.3.2. Исключение: переопределения
Javadoc может отсутствовать для методов, которые переопределяют методы суперкласса.

#### 7.3.4. Необязательный Javadoc
Другие классы и члены могут документироваться с помощью Javadoc *по мере необходимости или по желанию*.

Всякий раз, когда комментарий реализации будет использоваться для определения общего назначения или поведения класса или члена, этот комментарий должен записываться как Javadoc (с использованием `/**`).

Необязательный Javadoc может не следовать правилам форматирования, описанным в Разделах [п.7.1.2](#параграфы), [п.7.1.3](#теги-блоков) и [п.7.2](#фрагмент-краткой-информации), хотя это, конечно, рекомендуется.
